title: 为什么nodejs支持高并发、非阻塞
date: 2015-07-15 13:36
tags:
- nodejs
categories: 日志
---

**为什么nodejs支持高并发、非阻塞**
首先看一下nodejs的特点：
1 js运行环境， 依赖于chrome V8引擎进行代码解释
2 事件驱动
3 非阻塞I/O
4 轻量，可伸缩
5 单进程单线程

那么nodejs怎么实现高并发和非阻塞的， 我们看一下系统瓶颈的问题：
1 并发连接：
1.1 系统线程模型
     服务端只有一个线程， 并发请求（用户）到达的只能处理一个，其余的要先等待，这样就是阻塞，正在享受服务的请求阻塞后面的请求。
1.2 多线程、线程池模型
     多线程： 多个业务员， 高并发的时候还是需要排队。 调节服务端线程的数目来提高对并发请求的接收和相应。由于系统内存资源的受限， 多线程是有限的

1.3 nodejs实现的高并发的 异步、事件驱动模型
 每个用户请求都会得到处理， 服务端给请求注册一个激发事件（I/O）， 并给一个回调函数， 然后再事件处理（I/O）处理完成后继续执行下一步回调函数。 
这样子整个过程是没有阻塞新的用户的链接。
但是nodejs是单线程，这样子事件队列越长， 得到相应的时间越长， 并发量会力不从心。

解决： 
更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，
　　而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）




2  I/O阻塞

每个线程大概会占用 2M 的系统内存
2.1 针对串行获取数据，我们就是数据的相加，


2.2 nodejs
所有请求以及同时传入的回调函数均发送至同一线程，该线程通常叫做 Event loop 线程，该线程负责在 I/O 执行完毕后，将结果返回给回调函数。这里要注意的是 I/O 操作本身并不在该线程内执行，所以不会阻塞后续请求

![image](./img/nodejs/paixu.jpg)
![image](./img/nodejs/code.jpg)
![image](./img/nodejs/nodejs.jpg)
![image](./img/nodejs/org.jpg)



三. NodeJS的优缺点

　　优点：

　　1. 高并发（最重要的优点）

　　2. 适合I/O密集型应用


　   缺点：

　　1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；

　　　　解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；

　　2. 只支持单核CPU，不能充分利用CPU

　　3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

　　　　原因：单进程，单线程

　　　　解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；

　　　　　　　　　（2）开多个进程监听同一个端口，使用cluster模块；

　　4. 开源组件库质量参差不齐，更新快，向下不兼容

　　5. Debug不方便，错误没有stack trace
